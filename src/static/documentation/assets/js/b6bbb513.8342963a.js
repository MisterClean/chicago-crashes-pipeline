"use strict";(self.webpackChunkchicago_crashes_pipeline_docs=self.webpackChunkchicago_crashes_pipeline_docs||[]).push([[452],{3054:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>m,frontMatter:()=>a,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"agents/backend-architecture-examples","title":"Backend Architecture Agent - Usage Examples","description":"This document provides real-world examples of using the Backend Architecture Agent for the Chicago Traffic Crash Data Pipeline project.","source":"@site/docs/agents/backend-architecture-examples.md","sourceDirName":"agents","slug":"/agents/backend-architecture-examples","permalink":"/documentation/agents/backend-architecture-examples","draft":false,"unlisted":false,"editUrl":"https://github.com/MisterClean/chicago-crashes-pipeline/tree/main/docs/agents/backend-architecture-examples.md","tags":[],"version":"current","lastUpdatedAt":1765657045000,"frontMatter":{}}');var s=t(4848),r=t(8453);const a={},l="Backend Architecture Agent - Usage Examples",d={},o=[{value:"Example 1: Design New Data Source Integration (Traffic Signals)",id:"example-1-design-new-data-source-integration-traffic-signals",level:2},{value:"User Request",id:"user-request",level:3},{value:"Agent Workflow",id:"agent-workflow",level:3},{value:"Step 1: Create SQLAlchemy Model",id:"step-1-create-sqlalchemy-model",level:4},{value:"Step 2: Add Sanitizer",id:"step-2-add-sanitizer",level:4},{value:"Step 3: Add Database Service Method",id:"step-3-add-database-service-method",level:4},{value:"Step 4: Update SyncService",id:"step-4-update-syncservice",level:4},{value:"Step 5: Add API Configuration",id:"step-5-add-api-configuration",level:4},{value:"Step 6: Create Database Migration",id:"step-6-create-database-migration",level:4},{value:"Step 7: Add Test Coverage",id:"step-7-add-test-coverage",level:4},{value:"Step 8: Test the Integration",id:"step-8-test-the-integration",level:4},{value:"Expected Outcome",id:"expected-outcome",level:3},{value:"Example 2: Optimize Slow Spatial Query (Crashes Near Intersections)",id:"example-2-optimize-slow-spatial-query-crashes-near-intersections",level:2},{value:"User Request",id:"user-request-1",level:3},{value:"Agent Workflow",id:"agent-workflow-1",level:3},{value:"Step 1: Analyze Current Query",id:"step-1-analyze-current-query",level:4},{value:"Step 2: Fix SRID Issue",id:"step-2-fix-srid-issue",level:4},{value:"Step 3: Add Optimized Indexes",id:"step-3-add-optimized-indexes",level:4},{value:"Step 4: Implement Optimized Service Method",id:"step-4-implement-optimized-service-method",level:4},{value:"Step 5: Add API Endpoint",id:"step-5-add-api-endpoint",level:4},{value:"Step 6: Create Database Migration",id:"step-6-create-database-migration-1",level:4},{value:"Step 7: Verify Performance",id:"step-7-verify-performance",level:4},{value:"Expected Outcome",id:"expected-outcome-1",level:3},{value:"Example 3: Implement Rate Limiting Middleware",id:"example-3-implement-rate-limiting-middleware",level:2},{value:"User Request",id:"user-request-2",level:3},{value:"Agent Workflow",id:"agent-workflow-2",level:3},{value:"Step 1: Install Dependencies",id:"step-1-install-dependencies",level:4},{value:"Step 2: Configure Redis",id:"step-2-configure-redis",level:4},{value:"Step 3: Create Rate Limit Middleware",id:"step-3-create-rate-limit-middleware",level:4},{value:"Step 4: Apply Middleware to FastAPI App",id:"step-4-apply-middleware-to-fastapi-app",level:4},{value:"Step 5: Apply Rate Limits to Endpoints",id:"step-5-apply-rate-limits-to-endpoints",level:4},{value:"Step 6: Add Dependency-Based Rate Limiting",id:"step-6-add-dependency-based-rate-limiting",level:4},{value:"Step 7: Add Monitoring and Metrics",id:"step-7-add-monitoring-and-metrics",level:4},{value:"Step 8: Test Rate Limiting",id:"step-8-test-rate-limiting",level:4},{value:"Expected Outcome",id:"expected-outcome-2",level:3},{value:"Summary",id:"summary",level:2}];function c(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"backend-architecture-agent---usage-examples",children:"Backend Architecture Agent - Usage Examples"})}),"\n",(0,s.jsxs)(n.p,{children:["This document provides real-world examples of using the ",(0,s.jsx)(n.strong,{children:"Backend Architecture Agent"})," for the Chicago Traffic Crash Data Pipeline project."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"example-1-design-new-data-source-integration-traffic-signals",children:"Example 1: Design New Data Source Integration (Traffic Signals)"}),"\n",(0,s.jsx)(n.h3,{id:"user-request",children:"User Request"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:'"Can you help me add traffic signals from the Chicago Open Data Portal as a new data source?"'}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"agent-workflow",children:"Agent Workflow"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Complete end-to-end implementation following layered architecture"})}),"\n",(0,s.jsx)(n.h4,{id:"step-1-create-sqlalchemy-model",children:"Step 1: Create SQLAlchemy Model"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# src/models/traffic_signals.py\nfrom sqlalchemy import Column, String, Integer, Float, DateTime, Index\nfrom geoalchemy2 import Geometry\nfrom src.models.base import Base, TimestampMixin\n\nclass TrafficSignal(Base, TimestampMixin):\n    \"\"\"Traffic signal locations and metadata from Chicago Open Data Portal.\"\"\"\n\n    __tablename__ = \"traffic_signals\"\n\n    signal_id = Column(String(128), primary_key=True)\n    latitude = Column(Float, nullable=False)\n    longitude = Column(Float, nullable=False)\n    geometry = Column(Geometry('POINT', srid=4326), nullable=True)\n    street_name = Column(String(255))\n    cross_street = Column(String(255))\n    signal_type = Column(String(100))\n    installation_date = Column(DateTime)\n    operational_status = Column(String(50))\n\n    __table_args__ = (\n        Index('ix_traffic_signals_location', 'latitude', 'longitude'),\n        Index('ix_traffic_signals_geometry', 'geometry', postgresql_using='gist'),\n        Index('ix_traffic_signals_street', 'street_name'),\n    )\n\n    def __repr__(self):\n        return f\"<TrafficSignal(signal_id={self.signal_id}, street={self.street_name})>\"\n"})}),"\n",(0,s.jsx)(n.h4,{id:"step-2-add-sanitizer",children:"Step 2: Add Sanitizer"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# src/validators/data_sanitizer.py (add method)\ndef sanitize_traffic_signal_record(self, record: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Sanitize traffic signal record.\"\"\"\n    sanitized = {}\n\n    sanitized['signal_id'] = self._clean_string(record.get('signal_id'))\n    sanitized['latitude'] = self._clean_coordinate(record.get('latitude'), 'latitude')\n    sanitized['longitude'] = self._clean_coordinate(record.get('longitude'), 'longitude')\n    sanitized['street_name'] = self._clean_string(record.get('street_name'))\n    sanitized['cross_street'] = self._clean_string(record.get('cross_street'))\n    sanitized['signal_type'] = self._clean_string(record.get('signal_type'))\n    sanitized['installation_date'] = self._parse_datetime(record.get('installation_date'))\n    sanitized['operational_status'] = self._clean_string(record.get('operational_status'))\n\n    # Create PostGIS geometry\n    if sanitized['latitude'] and sanitized['longitude']:\n        sanitized['geometry'] = f\"SRID=4326;POINT({sanitized['longitude']} {sanitized['latitude']})\"\n\n    return sanitized\n"})}),"\n",(0,s.jsx)(n.h4,{id:"step-3-add-database-service-method",children:"Step 3: Add Database Service Method"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# src/services/database_service.py (add method)\ndef upsert_traffic_signal_records(self, records: Sequence[Dict[str, Any]]) -> Dict[str, int]:\n    \"\"\"Upsert traffic signal records.\"\"\"\n    return self._upsert_records(\n        model=TrafficSignal,\n        records=records,\n        prepare=self._prepare_traffic_signal_record\n    )\n\ndef _prepare_traffic_signal_record(self, record: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n    \"\"\"Prepare traffic signal record for database insertion.\"\"\"\n    if not record.get('signal_id'):\n        return None\n\n    prepared = {\n        'signal_id': record['signal_id'],\n        'latitude': record.get('latitude'),\n        'longitude': record.get('longitude'),\n        'street_name': record.get('street_name'),\n        'cross_street': record.get('cross_street'),\n        'signal_type': record.get('signal_type'),\n        'installation_date': record.get('installation_date'),\n        'operational_status': record.get('operational_status')\n    }\n\n    # Handle PostGIS geometry\n    if record.get('geometry'):\n        from geoalchemy2.elements import WKTElement\n        prepared['geometry'] = WKTElement(record['geometry'])\n\n    return prepared\n"})}),"\n",(0,s.jsx)(n.h4,{id:"step-4-update-syncservice",children:"Step 4: Update SyncService"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# src/services/sync_service.py (update _sync_single_endpoint)\nasync def _sync_single_endpoint(self, client, endpoint: str, ...) -> EndpointSyncResult:\n    \"\"\"Sync single endpoint with appropriate sanitizer and database method.\"\"\"\n\n    # Map endpoint to handlers\n    endpoint_handlers = {\n        'crashes': (self.sanitizer.sanitize_crash_record, self.database_service.upsert_crash_records),\n        'people': (self.sanitizer.sanitize_person_record, self.database_service.upsert_person_records),\n        'vehicles': (self.sanitizer.sanitize_vehicle_record, self.database_service.upsert_vehicle_records),\n        'traffic_signals': (  # NEW\n            self.sanitizer.sanitize_traffic_signal_record,\n            self.database_service.upsert_traffic_signal_records\n        )\n    }\n\n    sanitizer_func, database_func = endpoint_handlers.get(endpoint)\n\n    async for batch in client.iter_batches(...):\n        # Sanitize batch\n        cleaned = [sanitizer_func(record) for record in batch if sanitizer_func(record)]\n        # Persist to database\n        result = database_func(cleaned)\n        # ...\n"})}),"\n",(0,s.jsx)(n.h4,{id:"step-5-add-api-configuration",children:"Step 5: Add API Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# src/utils/config.py (update APISettings)\nclass APISettings(BaseSettings):\n    endpoints: Dict[str, str] = {\n        "crashes": "https://data.cityofchicago.org/resource/85ca-t3if.json",\n        "people": "https://data.cityofchicago.org/resource/u6pd-qa9d.json",\n        "vehicles": "https://data.cityofchicago.org/resource/68nd-jvt3.json",\n        "vision_zero": "https://data.cityofchicago.org/resource/gzaz-isa6.json",\n        "traffic_signals": "https://data.cityofchicago.org/resource/kfyz-pdh6.json"  # NEW\n    }\n'})}),"\n",(0,s.jsx)(n.h4,{id:"step-6-create-database-migration",children:"Step 6: Create Database Migration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"alembic revision --autogenerate -m \"add traffic signals table\"\n\n# Review generated migration\n# alembic/versions/def456_add_traffic_signals_table.py\n\ndef upgrade():\n    op.create_table(\n        'traffic_signals',\n        sa.Column('signal_id', sa.String(128), primary_key=True),\n        sa.Column('latitude', sa.Float(), nullable=False),\n        sa.Column('longitude', sa.Float(), nullable=False),\n        sa.Column('geometry', geoalchemy2.Geometry('POINT', srid=4326), nullable=True),\n        sa.Column('street_name', sa.String(255)),\n        sa.Column('cross_street', sa.String(255)),\n        sa.Column('signal_type', sa.String(100)),\n        sa.Column('installation_date', sa.DateTime()),\n        sa.Column('operational_status', sa.String(50)),\n        sa.Column('created_at', sa.DateTime(), server_default=sa.text('NOW()')),\n        sa.Column('updated_at', sa.DateTime(), server_default=sa.text('NOW()')),\n    )\n    op.create_index('ix_traffic_signals_location', 'traffic_signals', ['latitude', 'longitude'])\n    op.create_index('ix_traffic_signals_geometry', 'traffic_signals', ['geometry'], postgresql_using='gist')\n    op.create_index('ix_traffic_signals_street', 'traffic_signals', ['street_name'])\n\n# Apply migration\nalembic upgrade head\n"})}),"\n",(0,s.jsx)(n.h4,{id:"step-7-add-test-coverage",children:"Step 7: Add Test Coverage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# tests/test_traffic_signals.py\nimport pytest\nfrom src.validators.data_sanitizer import DataSanitizer\nfrom src.services.database_service import DatabaseService\nfrom src.models.traffic_signals import TrafficSignal\n\n@pytest.fixture\ndef sample_signal_record():\n    return {\n        "signal_id": "SIG001",\n        "latitude": "41.8781",\n        "longitude": "-87.6298",\n        "street_name": "MICHIGAN AVE",\n        "cross_street": "MADISON ST",\n        "signal_type": "TRAFFIC SIGNAL",\n        "installation_date": "2020-01-15T00:00:00.000",\n        "operational_status": "ACTIVE"\n    }\n\ndef test_sanitize_traffic_signal_record(sample_signal_record):\n    sanitizer = DataSanitizer()\n    result = sanitizer.sanitize_traffic_signal_record(sample_signal_record)\n\n    assert result[\'signal_id\'] == "SIG001"\n    assert result[\'latitude\'] == 41.8781\n    assert result[\'longitude\'] == -87.6298\n    assert result[\'street_name\'] == "MICHIGAN AVE"\n    assert "POINT(-87.6298 41.8781)" in result[\'geometry\']\n\ndef test_upsert_traffic_signal_records(sample_signal_record):\n    sanitizer = DataSanitizer()\n    db_service = DatabaseService()\n\n    sanitized = sanitizer.sanitize_traffic_signal_record(sample_signal_record)\n    result = db_service.upsert_traffic_signal_records([sanitized])\n\n    assert result[\'inserted\'] == 1\n    assert result[\'updated\'] == 0\n'})}),"\n",(0,s.jsx)(n.h4,{id:"step-8-test-the-integration",children:"Step 8: Test the Integration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'# Test sync\ncurl -X POST http://localhost:8000/sync/trigger \\\n  -H "Content-Type: application/json" \\\n  -d \'{\n    "endpoint": "traffic_signals",\n    "force": true\n  }\'\n\n# Check database\npsql -U postgres -d chicago_crashes -c "SELECT COUNT(*) FROM traffic_signals;"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"expected-outcome",children:"Expected Outcome"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Result"}),": Complete traffic signals integration with:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"\u2705 Database model with PostGIS geometry"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Data sanitization logic"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Idempotent upsert operations"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Integration with sync service"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Database migration"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Spatial indexes for performance"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Test coverage"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 API configuration"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"example-2-optimize-slow-spatial-query-crashes-near-intersections",children:"Example 2: Optimize Slow Spatial Query (Crashes Near Intersections)"}),"\n",(0,s.jsx)(n.h3,{id:"user-request-1",children:"User Request"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:'"This query to find crashes within 100 meters of traffic signals is timing out. Can you optimize it?"'}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"agent-workflow-1",children:"Agent Workflow"}),"\n",(0,s.jsx)(n.h4,{id:"step-1-analyze-current-query",children:"Step 1: Analyze Current Query"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Current query (SLOW)\nSELECT c.crash_record_id, c.crash_date, c.street_name\nFROM crashes c, traffic_signals ts\nWHERE ST_DWithin(\n    c.geometry,\n    ts.geometry,\n    100  -- This is in DEGREES, not meters!\n)\nLIMIT 1000;\n\n-- EXPLAIN ANALYZE shows:\n-- Nested Loop (cost=0.00..250000.00 rows=1000000 width=100) (actual time=45000.123..60000.456 rows=50000 loops=1)\n-- -> Seq Scan on crashes (cost=0.00..50000.00 rows=1000000)\n-- -> Seq Scan on traffic_signals (cost=0.00..200.00 rows=5000)\n-- Planning Time: 1.234 ms\n-- Execution Time: 60123.456 ms  \u2190 60 SECONDS!\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problems Identified"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Wrong SRID usage"}),": ST_DWithin with SRID 4326 expects degrees, not meters"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No index usage"}),": Sequential scans on both tables"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cartesian join"}),": Every crash checked against every signal"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"step-2-fix-srid-issue",children:"Step 2: Fix SRID Issue"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Option A: Transform to planar projection (State Plane Illinois)\nSELECT c.crash_record_id, c.crash_date, c.street_name\nFROM crashes c\nJOIN traffic_signals ts ON ST_DWithin(\n    ST_Transform(c.geometry, 3435),  -- Transform to Illinois State Plane (feet)\n    ST_Transform(ts.geometry, 3435),\n    328  -- 100 meters = 328 feet\n)\nLIMIT 1000;\n\n-- Option B: Use geography type (spherical calculations, slower but accurate)\nSELECT c.crash_record_id, c.crash_date, c.street_name\nFROM crashes c\nJOIN traffic_signals ts ON ST_DWithin(\n    c.geometry::geography,\n    ts.geometry::geography,\n    100  -- 100 meters\n)\nLIMIT 1000;\n\n-- Option C: Pre-filter with bounding box (fastest)\nSELECT c.crash_record_id, c.crash_date, c.street_name\nFROM crashes c\nJOIN traffic_signals ts ON\n    ST_DWithin(\n        c.geometry,\n        ts.geometry,\n        0.001  -- ~100m in degrees (approximate)\n    )\n    AND ST_Distance(\n        c.geometry::geography,\n        ts.geometry::geography\n    ) <= 100  -- Exact distance check\nLIMIT 1000;\n"})}),"\n",(0,s.jsx)(n.h4,{id:"step-3-add-optimized-indexes",children:"Step 3: Add Optimized Indexes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Create GIST indexes if not exist\nCREATE INDEX IF NOT EXISTS ix_crashes_geometry ON crashes USING GIST(geometry);\nCREATE INDEX IF NOT EXISTS ix_traffic_signals_geometry ON traffic_signals USING GIST(geometry);\n\n-- Add transformed geometry columns for State Plane\nALTER TABLE crashes ADD COLUMN geometry_state_plane GEOMETRY(POINT, 3435);\nALTER TABLE traffic_signals ADD COLUMN geometry_state_plane GEOMETRY(POINT, 3435);\n\n-- Populate transformed geometries\nUPDATE crashes SET geometry_state_plane = ST_Transform(geometry, 3435) WHERE geometry IS NOT NULL;\nUPDATE traffic_signals SET geometry_state_plane = ST_Transform(geometry, 3435) WHERE geometry IS NOT NULL;\n\n-- Index transformed geometries\nCREATE INDEX ix_crashes_geometry_state_plane ON crashes USING GIST(geometry_state_plane);\nCREATE INDEX ix_traffic_signals_geometry_state_plane ON traffic_signals USING GIST(geometry_state_plane);\n"})}),"\n",(0,s.jsx)(n.h4,{id:"step-4-implement-optimized-service-method",children:"Step 4: Implement Optimized Service Method"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# src/services/crash_service.py\nfrom typing import List, Dict, Any\nfrom sqlalchemy import func\nfrom geoalchemy2.functions import ST_DWithin, ST_Transform, ST_Distance\nfrom src.models.crashes import Crash\nfrom src.models.traffic_signals import TrafficSignal\n\nclass CrashService:\n    def __init__(self, session):\n        self.session = session\n\n    def get_crashes_near_signals(\n        self,\n        distance_meters: int = 100,\n        limit: int = 1000\n    ) -> List[Dict[str, Any]]:\n        \"\"\"Get crashes within specified distance of traffic signals.\n\n        Uses State Plane Illinois (SRID 3435) for accurate distance calculations.\n\n        Args:\n            distance_meters: Distance in meters\n            limit: Maximum results\n\n        Returns:\n            List of crash records with distance to nearest signal\n        \"\"\"\n        # Convert meters to feet (State Plane Illinois is in feet)\n        distance_feet = distance_meters * 3.28084\n\n        # Use pre-transformed geometry for performance\n        query = self.session.query(\n            Crash.crash_record_id,\n            Crash.crash_date,\n            Crash.street_name,\n            Crash.latitude,\n            Crash.longitude,\n            TrafficSignal.signal_id,\n            TrafficSignal.street_name.label('signal_street'),\n            func.round(\n                ST_Distance(\n                    Crash.geometry_state_plane,\n                    TrafficSignal.geometry_state_plane\n                ) / 3.28084,  # Convert feet back to meters\n                2\n            ).label('distance_meters')\n        ).join(\n            TrafficSignal,\n            ST_DWithin(\n                Crash.geometry_state_plane,\n                TrafficSignal.geometry_state_plane,\n                distance_feet\n            )\n        ).order_by(\n            Crash.crash_date.desc()\n        ).limit(limit)\n\n        return [\n            {\n                'crash_record_id': row.crash_record_id,\n                'crash_date': row.crash_date.isoformat(),\n                'street_name': row.street_name,\n                'latitude': row.latitude,\n                'longitude': row.longitude,\n                'nearest_signal_id': row.signal_id,\n                'signal_street': row.signal_street,\n                'distance_meters': float(row.distance_meters)\n            }\n            for row in query\n        ]\n"})}),"\n",(0,s.jsx)(n.h4,{id:"step-5-add-api-endpoint",children:"Step 5: Add API Endpoint"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# src/api/routers/spatial.py\nfrom fastapi import APIRouter, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom src.models.base import get_db\nfrom src.services.crash_service import CrashService\n\nrouter = APIRouter(prefix="/spatial", tags=["spatial"])\n\n@router.get("/crashes/near-signals")\nasync def get_crashes_near_signals(\n    distance: int = Query(default=100, ge=10, le=1000, description="Distance in meters"),\n    limit: int = Query(default=100, ge=1, le=10000, description="Max results"),\n    db: Session = Depends(get_db)\n):\n    """Get crashes within specified distance of traffic signals."""\n    service = CrashService(db)\n    return service.get_crashes_near_signals(\n        distance_meters=distance,\n        limit=limit\n    )\n'})}),"\n",(0,s.jsx)(n.h4,{id:"step-6-create-database-migration-1",children:"Step 6: Create Database Migration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'alembic revision -m "add state plane geometry columns for performance"\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# alembic/versions/ghi789_add_state_plane_geometry.py\ndef upgrade():\n    # Add transformed geometry columns\n    op.add_column('crashes', sa.Column('geometry_state_plane', geoalchemy2.Geometry('POINT', srid=3435)))\n    op.add_column('traffic_signals', sa.Column('geometry_state_plane', geoalchemy2.Geometry('POINT', srid=3435)))\n\n    # Populate from existing geometry\n    op.execute(\"\"\"\n        UPDATE crashes\n        SET geometry_state_plane = ST_Transform(geometry, 3435)\n        WHERE geometry IS NOT NULL\n    \"\"\")\n\n    op.execute(\"\"\"\n        UPDATE traffic_signals\n        SET geometry_state_plane = ST_Transform(geometry, 3435)\n        WHERE geometry IS NOT NULL\n    \"\"\")\n\n    # Create GIST indexes\n    op.create_index(\n        'ix_crashes_geometry_state_plane',\n        'crashes',\n        ['geometry_state_plane'],\n        postgresql_using='gist'\n    )\n\n    op.create_index(\n        'ix_traffic_signals_geometry_state_plane',\n        'traffic_signals',\n        ['geometry_state_plane'],\n        postgresql_using='gist'\n    )\n\ndef downgrade():\n    op.drop_index('ix_traffic_signals_geometry_state_plane', table_name='traffic_signals')\n    op.drop_index('ix_crashes_geometry_state_plane', table_name='crashes')\n    op.drop_column('traffic_signals', 'geometry_state_plane')\n    op.drop_column('crashes', 'geometry_state_plane')\n"})}),"\n",(0,s.jsx)(n.h4,{id:"step-7-verify-performance",children:"Step 7: Verify Performance"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- Test optimized query\nEXPLAIN ANALYZE\nSELECT c.crash_record_id, c.crash_date\nFROM crashes c\nJOIN traffic_signals ts ON ST_DWithin(\n    c.geometry_state_plane,\n    ts.geometry_state_plane,\n    328  -- 100 meters in feet\n)\nLIMIT 1000;\n\n-- Expected output:\n-- Nested Loop (cost=0.42..125.67 rows=1000 width=50) (actual time=0.123..45.678 rows=1000 loops=1)\n-- -> Index Scan using ix_traffic_signals_geometry_state_plane on traffic_signals\n-- -> Index Scan using ix_crashes_geometry_state_plane on crashes\n--    Index Cond: ST_DWithin(geometry_state_plane, ts.geometry_state_plane, 328)\n-- Planning Time: 0.456 ms\n-- Execution Time: 47.234 ms  \u2190 99.9% FASTER!\n"})}),"\n",(0,s.jsx)(n.h3,{id:"expected-outcome-1",children:"Expected Outcome"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Result"}),": Optimized spatial query with:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"\u2705 99.9% performance improvement (60s \u2192 47ms)"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Correct distance calculations (meters, not degrees)"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Spatial index usage (GIST indexes)"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 State Plane projection for accuracy"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Clean service layer API"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 RESTful endpoint with validation"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Database migration for schema changes"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Before/After"}),":"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Metric"}),(0,s.jsx)(n.th,{children:"Before"}),(0,s.jsx)(n.th,{children:"After"}),(0,s.jsx)(n.th,{children:"Improvement"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Execution time"}),(0,s.jsx)(n.td,{children:"60,123ms"}),(0,s.jsx)(n.td,{children:"47ms"}),(0,s.jsx)(n.td,{children:"99.92% faster"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Index usage"}),(0,s.jsx)(n.td,{children:"None (seq scans)"}),(0,s.jsx)(n.td,{children:"GIST indexes"}),(0,s.jsx)(n.td,{children:"\u2705"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Distance accuracy"}),(0,s.jsx)(n.td,{children:"Wrong (degrees)"}),(0,s.jsx)(n.td,{children:"Correct (meters)"}),(0,s.jsx)(n.td,{children:"\u2705"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Scalability"}),(0,s.jsx)(n.td,{children:"Poor (cartesian)"}),(0,s.jsx)(n.td,{children:"Good (indexed join)"}),(0,s.jsx)(n.td,{children:"\u2705"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"example-3-implement-rate-limiting-middleware",children:"Example 3: Implement Rate Limiting Middleware"}),"\n",(0,s.jsx)(n.h3,{id:"user-request-2",children:"User Request"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:'"We\'re getting hammered by API requests. Can you add rate limiting to protect the server?"'}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"agent-workflow-2",children:"Agent Workflow"}),"\n",(0,s.jsx)(n.h4,{id:"step-1-install-dependencies",children:"Step 1: Install Dependencies"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"pip install slowapi redis\n"})}),"\n",(0,s.jsx)(n.h4,{id:"step-2-configure-redis",children:"Step 2: Configure Redis"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# src/utils/config.py\nclass RateLimitSettings(BaseSettings):\n    enabled: bool = Field(default=True, env="RATE_LIMIT_ENABLED")\n    redis_url: str = Field(default="redis://localhost:6379", env="REDIS_URL")\n    default_limit: str = Field(default="100/minute", env="RATE_LIMIT_DEFAULT")\n    authenticated_limit: str = Field(default="1000/minute", env="RATE_LIMIT_AUTHENTICATED")\n\nclass Settings(BaseSettings):\n    # ... existing settings ...\n    rate_limit: RateLimitSettings = RateLimitSettings()\n'})}),"\n",(0,s.jsx)(n.h4,{id:"step-3-create-rate-limit-middleware",children:"Step 3: Create Rate Limit Middleware"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# src/api/middleware/rate_limit.py\nfrom slowapi import Limiter, _rate_limit_exceeded_handler\nfrom slowapi.util import get_remote_address\nfrom slowapi.errors import RateLimitExceeded\nfrom fastapi import Request, HTTPException\nfrom src.utils.config import settings\n\n# Create limiter instance\nlimiter = Limiter(\n    key_func=get_remote_address,\n    storage_uri=settings.rate_limit.redis_url,\n    enabled=settings.rate_limit.enabled\n)\n\ndef get_rate_limit_key(request: Request) -> str:\n    """Get rate limit key based on authentication status."""\n    # Check for API key in header\n    api_key = request.headers.get("X-API-Key")\n    if api_key and verify_api_key(api_key):\n        return f"authenticated:{api_key}"\n\n    # Fall back to IP address\n    return get_remote_address(request)\n\ndef verify_api_key(api_key: str) -> bool:\n    """Verify API key (implement your logic)."""\n    # In production, check against database or secrets manager\n    return api_key == settings.api_key_secret\n'})}),"\n",(0,s.jsx)(n.h4,{id:"step-4-apply-middleware-to-fastapi-app",children:"Step 4: Apply Middleware to FastAPI App"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# src/api/main.py\nfrom slowapi import _rate_limit_exceeded_handler\nfrom slowapi.errors import RateLimitExceeded\nfrom src.api.middleware.rate_limit import limiter\nfrom src.utils.config import settings\n\napp = FastAPI(...)\n\n# Add rate limiter state\napp.state.limiter = limiter\n\n# Add exception handler\napp.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)\n\n# Custom error response\n@app.exception_handler(RateLimitExceeded)\nasync def custom_rate_limit_handler(request: Request, exc: RateLimitExceeded):\n    """Return custom error response for rate limit exceeded."""\n    return JSONResponse(\n        status_code=429,\n        content={\n            "error": "rate_limit_exceeded",\n            "detail": "Too many requests. Please try again later.",\n            "retry_after": exc.retry_after  # Seconds until next allowed request\n        },\n        headers={\n            "Retry-After": str(exc.retry_after),\n            "X-RateLimit-Limit": str(exc.limit),\n            "X-RateLimit-Remaining": "0",\n            "X-RateLimit-Reset": str(exc.reset)\n        }\n    )\n'})}),"\n",(0,s.jsx)(n.h4,{id:"step-5-apply-rate-limits-to-endpoints",children:"Step 5: Apply Rate Limits to Endpoints"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# src/api/routers/sync.py\nfrom src.api.middleware.rate_limit import limiter\nfrom src.utils.config import settings\n\n@router.post("/sync/trigger")\n@limiter.limit(settings.rate_limit.default_limit)  # 100 requests/minute\nasync def trigger_sync(request: Request, sync_request: SyncRequest, ...):\n    """Trigger manual sync with rate limiting."""\n    # ... existing logic\n\n# Different limits for different endpoints\n@router.get("/sync/status")\n@limiter.limit("1000/minute")  # Higher limit for read-only\nasync def get_sync_status(request: Request):\n    """Get sync status (higher rate limit for reads)."""\n    # ... existing logic\n\n@router.post("/sync/test")\n@limiter.limit("10/minute")  # Lower limit for expensive operations\nasync def test_sync(request: Request, ...):\n    """Test sync (lower limit for expensive operation)."""\n    # ... existing logic\n'})}),"\n",(0,s.jsx)(n.h4,{id:"step-6-add-dependency-based-rate-limiting",children:"Step 6: Add Dependency-Based Rate Limiting"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# src/api/dependencies.py\nfrom slowapi import Limiter\nfrom fastapi import Request, Depends, HTTPException\nfrom src.api.middleware.rate_limit import limiter, get_rate_limit_key\n\ndef rate_limit_dependency(limit: str):\n    """Create a rate limit dependency."""\n    async def _rate_limit(request: Request):\n        try:\n            await limiter.check_rate_limit(request, limit)\n        except RateLimitExceeded as e:\n            raise HTTPException(\n                status_code=429,\n                detail="Rate limit exceeded",\n                headers={"Retry-After": str(e.retry_after)}\n            )\n    return _rate_limit\n\n# Usage in routers\n@router.post("/jobs/")\nasync def create_job(\n    job_data: CreateJobRequest,\n    _: None = Depends(rate_limit_dependency("50/minute"))\n):\n    """Create job with custom rate limit."""\n    # ... existing logic\n'})}),"\n",(0,s.jsx)(n.h4,{id:"step-7-add-monitoring-and-metrics",children:"Step 7: Add Monitoring and Metrics"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# src/api/middleware/rate_limit.py\nimport structlog\nfrom prometheus_client import Counter, Histogram\n\nlogger = structlog.get_logger(__name__)\n\n# Prometheus metrics\nrate_limit_counter = Counter(\n    'rate_limit_exceeded_total',\n    'Number of rate limit exceeded errors',\n    ['endpoint', 'method']\n)\n\nrate_limit_latency = Histogram(\n    'rate_limit_check_seconds',\n    'Time spent checking rate limits',\n    ['endpoint']\n)\n\n# Middleware to track rate limit hits\n@app.middleware(\"http\")\nasync def track_rate_limits(request: Request, call_next):\n    endpoint = request.url.path\n\n    with rate_limit_latency.labels(endpoint=endpoint).time():\n        try:\n            response = await call_next(request)\n\n            # Add rate limit headers to all responses\n            if hasattr(request.state, 'view_rate_limit'):\n                response.headers[\"X-RateLimit-Limit\"] = str(request.state.view_rate_limit.limit)\n                response.headers[\"X-RateLimit-Remaining\"] = str(request.state.view_rate_limit.remaining)\n                response.headers[\"X-RateLimit-Reset\"] = str(request.state.view_rate_limit.reset)\n\n            return response\n\n        except RateLimitExceeded as e:\n            rate_limit_counter.labels(\n                endpoint=endpoint,\n                method=request.method\n            ).inc()\n\n            logger.warning(\n                \"Rate limit exceeded\",\n                endpoint=endpoint,\n                method=request.method,\n                client_ip=get_remote_address(request),\n                retry_after=e.retry_after\n            )\n\n            raise\n"})}),"\n",(0,s.jsx)(n.h4,{id:"step-8-test-rate-limiting",children:"Step 8: Test Rate Limiting"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'# Test with curl\nfor i in {1..150}; do\n  curl -w "\\nStatus: %{http_code}\\n" http://localhost:8000/sync/status\n  sleep 0.1\ndone\n\n# Expected: First 100 requests succeed, remaining get 429\n\n# Test with API key (higher limit)\nfor i in {1..150}; do\n  curl -H "X-API-Key: your-api-key" \\\n       -w "\\nStatus: %{http_code}\\n" \\\n       http://localhost:8000/sync/status\n  sleep 0.05\ndone\n\n# Expected: First 1000 requests succeed (authenticated limit)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"expected-outcome-2",children:"Expected Outcome"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Result"}),": Production-ready rate limiting with:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"\u2705 Redis-backed rate limit storage (distributed, persistent)"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Per-endpoint rate limits (flexible configuration)"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 API key-based authentication (higher limits for authenticated users)"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Custom error responses with retry headers"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Prometheus metrics for monitoring"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 Structured logging for debugging"}),"\n",(0,s.jsx)(n.li,{children:"\u2705 IP-based rate limiting for anonymous users"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Configuration Examples"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-env",children:"RATE_LIMIT_ENABLED=true\nREDIS_URL=redis://localhost:6379\nRATE_LIMIT_DEFAULT=100/minute\nRATE_LIMIT_AUTHENTICATED=1000/minute\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsxs)(n.p,{children:["These examples demonstrate the ",(0,s.jsx)(n.strong,{children:"Backend Architecture Agent's"})," capabilities:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"New data source integration"})," - Complete end-to-end implementation (model \u2192 service \u2192 API \u2192 migration \u2192 tests)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Spatial query optimization"})," - 99.9% performance improvement with proper indexing and SRID handling"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rate limiting middleware"})," - Production-ready protection with Redis, monitoring, and flexible limits"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The agent provides:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Complete implementations"})," following layered architecture"]}),"\n",(0,s.jsxs)(n.li,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Performance optimization"})," with EXPLAIN ANALYZE and proper indexing"]}),"\n",(0,s.jsxs)(n.li,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Production-ready patterns"})," (error handling, logging, monitoring)"]}),"\n",(0,s.jsxs)(n.li,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Database migrations"})," with up/down paths"]}),"\n",(0,s.jsxs)(n.li,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Comprehensive testing"})," for all new code"]}),"\n",(0,s.jsxs)(n.li,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Scalability"})," through proper architecture decisions"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Invoke the Backend Architecture Agent for complex backend features, performance optimization, and architectural decisions."})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var i=t(6540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);